# [FECONF22] 내 import문이 그렇게 이상했나요?

## `CommonJS`

이상한 import문의 기원 &rarr; 실제로는 require로 변하는 형식 (commonJS로 컴파일 하는 방식)

> CommonJS는 표준이 아니기 때문에 지원하지 않는 환경에서는 문제가 발생

### 문제점

- 정적 분석의 어려움
  > 트리쉐이킹이 어려워진다<br><br>
  > 동기적으로 동작한다 &rarr; 비동기 처리에 어려움<br><br>
  > commonJS에서 require는 함수이기 때문에 마음대로 재정의가 가능하다 &rarr; 안정성이 떨어진다

<br>

## `ESM` (ECMAScriptModuels)

진짜 import문 (표준)

- 정적 분석이 쉽다 (번들사이즈 줄임에 쉬움)
- 탑레벨 await 쉬운 모듈 선언
- 비동기적으로 동작

> 아직은 이관하기에는 이른 시점인듯. 대부분이 cjs환경이다

<br>

```
동기함수와 비동기함수의 관계

비동기에서 동기는 호출이 쉽다

하지만 역은 성립하기 어려움. cjs는 동기 esm은 비동기이다. 즉, esm에서 cjs를 부르는건 쉽지만 cjs에서 esm을 이용하는 것은 어렵다 => 에러 발생 => 우리 패키지를 esm으로 바꿔야만 해결 가능하다
```

&rarr; package.json에서 타입필드를 통해 esm으로 변경 가능 (디폴트는 cjs)
<br>
특정 케이스를 위해 .cjs와 .mjs로 동작시킬 수 있다

<br><hr><br>

## ESM이관시 어려운 점

1. 가짜 ESM
2. 생태계

<br>

- 가짜esm과 진짜esm의 차이

  > 가짜 esm은 확장자가 생략 가능(노드나 웹팩에서 지원해줌). 하지만 진짜는 안 됨 &rarr; 웹팩 번들링 속도가 느린 이유중 하나&rarr;바꾸기 위해서 확장자를 포함한 정확한 경로 필수

- 생태계
  > 대부분이 cjs 생태계로 되어 있어서 .cjs, .mjs등 여러가지 문제에 직면할 확률이 높음
